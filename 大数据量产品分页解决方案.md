# å¤§æ•°æ®é‡äº§å“åˆ†é¡µè§£å†³æ–¹æ¡ˆ

## ä¸€ã€é—®é¢˜èƒŒæ™¯

### 1.1 å½“å‰æ¶æ„é—®é¢˜

å½“å‰é¡¹ç›®æ˜¯çº¯å‰ç«¯é™æ€é¡¹ç›®ï¼Œäº§å“æ•°æ®å­˜å‚¨åœ¨ `public/data/products.json`ï¼Œè®¿é—®æ—¶ä¼šä¸€æ¬¡æ€§ä¸‹è½½å…¨éƒ¨æ•°æ®ï¼š

```
æ¸¸å®¢è®¿é—® â†’ ä¸‹è½½æ•´ä¸ªproducts.json(å¯èƒ½5MB+) â†’ å­˜å…¥å†…å­˜ â†’ å®¢æˆ·ç«¯åˆ†é¡µ
```

**é—®é¢˜**ï¼š
- ä¸Šä¸‡æ¡äº§å“æ•°æ®çº¦ 5-10MB
- é¦–æ¬¡åŠ è½½éœ€è¦ 10-30ç§’ï¼ˆ3Gç½‘ç»œï¼‰
- æµè§ˆå™¨å†…å­˜å ç”¨é«˜
- ç§»åŠ¨ç«¯ä½“éªŒå·®

### 1.2 ç›®æ ‡

å®ç°æœåŠ¡ç«¯åˆ†é¡µï¼Œæ¯æ¬¡åªè¯·æ±‚å½“å‰é¡µæ•°æ®ï¼ˆå¦‚12æ¡ï¼‰ï¼Œæ”¯æŒæœç´¢å’Œç­›é€‰ã€‚

---

## äºŒã€è§£å†³æ–¹æ¡ˆæ¦‚è¿°

ç”±äºé¡¹ç›®æ˜¯çº¯é™æ€é¡¹ç›®ï¼Œæˆ‘ä»¬æœ‰ä»¥ä¸‹å‡ ç§æ–¹æ¡ˆï¼š

| æ–¹æ¡ˆ | å¤æ‚åº¦ | æˆæœ¬ | æ¨èåº¦ | è¯´æ˜ |
|------|--------|------|--------|------|
| **A. Serverless Functions** | ä¸­ | å…è´¹ | â­â­â­â­â­ | æ¨èï¼ŒçœŸæ­£çš„æœåŠ¡ç«¯åˆ†é¡µ |
| **B. é™æ€æ•°æ®åˆ†ç‰‡** | ä½ | å…è´¹ | â­â­â­â­ | çº¯é™æ€ï¼Œé€‚åˆç®€å•åœºæ™¯ |
| **C. ç¬¬ä¸‰æ–¹BaaS** | ä¸­ | å…è´¹/ä»˜è´¹ | â­â­â­ | ä¾èµ–ç¬¬ä¸‰æ–¹æœåŠ¡ |

**æœ¬æ–‡æ¡£é‡ç‚¹ä»‹ç»æ–¹æ¡ˆAï¼ˆServerless Functionsï¼‰å’Œæ–¹æ¡ˆBï¼ˆé™æ€æ•°æ®åˆ†ç‰‡ï¼‰**

---

## ä¸‰ã€æ–¹æ¡ˆAï¼šServerless Functionsï¼ˆæ¨èï¼‰

### 3.1 æ–¹æ¡ˆåŸç†

ä½¿ç”¨ Vercel/Netlify æä¾›çš„ Serverless Functionsï¼Œåœ¨è¾¹ç¼˜èŠ‚ç‚¹è¿è¡Œè½»é‡çº§ APIï¼š

```
ç”¨æˆ·è¯·æ±‚ â†’ Serverless Function â†’ è¯»å–æ•°æ®å¹¶åˆ†é¡µ â†’ è¿”å›å½“å‰é¡µæ•°æ®
```

**ä¼˜ç‚¹**ï¼š
- çœŸæ­£çš„æœåŠ¡ç«¯åˆ†é¡µ
- æ”¯æŒå¤æ‚æœç´¢å’Œç­›é€‰
- å…è´¹é¢åº¦è¶³å¤Ÿï¼ˆVercel: 100GBå¸¦å®½/æœˆï¼‰
- éƒ¨ç½²ç®€å•ï¼Œä¸ Vue é¡¹ç›®ä¸€èµ·éƒ¨ç½²

### 3.2 é¡¹ç›®ç»“æ„è°ƒæ•´

```
project/
â”œâ”€â”€ api/                          # ğŸ†• Serverless API ç›®å½•
â”‚   â”œâ”€â”€ products.ts               # äº§å“åˆ—è¡¨API
â”‚   â”œâ”€â”€ products/
â”‚   â”‚   â””â”€â”€ [id].ts               # äº§å“è¯¦æƒ…API
â”‚   â””â”€â”€ _lib/
â”‚       â”œâ”€â”€ data-loader.ts        # æ•°æ®åŠ è½½å·¥å…·
â”‚       â””â”€â”€ types.ts              # ç±»å‹å®šä¹‰
â”œâ”€â”€ data/                         # ğŸ†• åŸå§‹æ•°æ®ç›®å½•ï¼ˆæ„å»ºæ—¶ä½¿ç”¨ï¼‰
â”‚   â””â”€â”€ products.json             # å®Œæ•´äº§å“æ•°æ®
â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ brands.json           # å“ç‰Œæ•°æ®ï¼ˆä¿æŒä¸å˜ï¼‰
â”‚   â”‚   â”œâ”€â”€ promotions.json       # ä¿ƒé”€æ•°æ®ï¼ˆä¿æŒä¸å˜ï¼‰
â”‚   â”‚   â””â”€â”€ products-meta.json    # ğŸ†• äº§å“å…ƒæ•°æ®ï¼ˆåˆ†ç±»ã€å“ç‰Œåˆ—è¡¨ç­‰ï¼‰
â”‚   â””â”€â”€ images/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â””â”€â”€ productStore.ts       # ğŸ”„ æ”¹é€ ä¸ºAPIè°ƒç”¨
â”‚   â””â”€â”€ ...
â”œâ”€â”€ scripts/                      # ğŸ†• æ„å»ºè„šæœ¬
â”‚   â””â”€â”€ generate-meta.ts          # ç”Ÿæˆå…ƒæ•°æ®è„šæœ¬
â”œâ”€â”€ vercel.json                   # ğŸ†• Vercelé…ç½®
â””â”€â”€ package.json
```

### 3.3 å®ç°æ­¥éª¤

#### æ­¥éª¤1ï¼šå®‰è£…ä¾èµ–

```bash
npm install -D @vercel/node
```

#### æ­¥éª¤2ï¼šåˆ›å»º Serverless API

**æ–‡ä»¶ï¼š`api/products.ts`**

```typescript
import type { VercelRequest, VercelResponse } from '@vercel/node'
import productsData from '../data/products.json'

interface Product {
  id: string
  name: string
  categoryId: string
  brand: string
  sku: string
  specs: string
  unit: string
  desc: string
}

interface QueryParams {
  page?: string
  pageSize?: string
  search?: string
  categoryId?: string
  brand?: string
  sortBy?: string
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  // è®¾ç½® CORS å¤´
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS')
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type')

  if (req.method === 'OPTIONS') {
    return res.status(200).end()
  }

  try {
    const {
      page = '1',
      pageSize = '12',
      search = '',
      categoryId = '',
      brand = '',
      sortBy = 'name-asc'
    } = req.query as QueryParams

    const pageNum = Math.max(1, parseInt(page, 10) || 1)
    const pageSizeNum = Math.min(100, Math.max(1, parseInt(pageSize, 10) || 12))

    // ç­›é€‰
    let filtered: Product[] = productsData as Product[]

    // æœç´¢ç­›é€‰
    if (search) {
      const keyword = search.toLowerCase()
      filtered = filtered.filter(p =>
        p.name.toLowerCase().includes(keyword) ||
        p.specs.toLowerCase().includes(keyword) ||
        p.desc.toLowerCase().includes(keyword) ||
        p.brand?.toLowerCase().includes(keyword) ||
        p.sku?.toLowerCase().includes(keyword)
      )
    }

    // åˆ†ç±»ç­›é€‰
    if (categoryId) {
      filtered = filtered.filter(p => p.categoryId === categoryId)
    }

    // å“ç‰Œç­›é€‰
    if (brand) {
      filtered = filtered.filter(p => p.brand === brand)
    }

    // æ’åº
    if (sortBy === 'name-asc') {
      filtered.sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'))
    } else if (sortBy === 'name-desc') {
      filtered.sort((a, b) => b.name.localeCompare(a.name, 'zh-CN'))
    }

    // åˆ†é¡µ
    const total = filtered.length
    const totalPages = Math.ceil(total / pageSizeNum)
    const startIndex = (pageNum - 1) * pageSizeNum
    const items = filtered.slice(startIndex, startIndex + pageSizeNum)

    // è¿”å›ç»“æœ
    return res.status(200).json({
      success: true,
      data: {
        items,
        pagination: {
          page: pageNum,
          pageSize: pageSizeNum,
          total,
          totalPages,
          hasNextPage: pageNum < totalPages,
          hasPrevPage: pageNum > 1
        }
      }
    })
  } catch (error) {
    console.error('API Error:', error)
    return res.status(500).json({
      success: false,
      error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
    })
  }
}
```

**æ–‡ä»¶ï¼š`api/products/[id].ts`**

```typescript
import type { VercelRequest, VercelResponse } from '@vercel/node'
import productsData from '../../data/products.json'

interface Product {
  id: string
  name: string
  categoryId: string
  brand: string
  sku: string
  specs: string
  unit: string
  desc: string
}

export default function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*')
  res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS')

  if (req.method === 'OPTIONS') {
    return res.status(200).end()
  }

  try {
    const { id } = req.query

    if (!id || typeof id !== 'string') {
      return res.status(400).json({
        success: false,
        error: 'æ— æ•ˆçš„äº§å“ID'
      })
    }

    const product = (productsData as Product[]).find(p => p.id === id)

    if (!product) {
      return res.status(404).json({
        success: false,
        error: 'äº§å“ä¸å­˜åœ¨'
      })
    }

    return res.status(200).json({
      success: true,
      data: product
    })
  } catch (error) {
    console.error('API Error:', error)
    return res.status(500).json({
      success: false,
      error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯'
    })
  }
}
```

#### æ­¥éª¤3ï¼šåˆ›å»ºå…ƒæ•°æ®ç”Ÿæˆè„šæœ¬

**æ–‡ä»¶ï¼š`scripts/generate-meta.ts`**

```typescript
/**
 * ç”Ÿæˆäº§å“å…ƒæ•°æ®è„šæœ¬
 * ç”¨äºç”Ÿæˆåˆ†ç±»åˆ—è¡¨ã€å“ç‰Œåˆ—è¡¨ç­‰é™æ€å…ƒæ•°æ®
 * è¿è¡Œå‘½ä»¤: npx ts-node scripts/generate-meta.ts
 */

import * as fs from 'fs'
import * as path from 'path'

interface Product {
  id: string
  name: string
  categoryId: string
  brand: string
}

// è¯»å–äº§å“æ•°æ®
const productsPath = path.join(__dirname, '../data/products.json')
const products: Product[] = JSON.parse(fs.readFileSync(productsPath, 'utf-8'))

// æå–æ‰€æœ‰å“ç‰Œ
const brands = [...new Set(products.map(p => p.brand).filter(Boolean))].sort()

// ç»Ÿè®¡å„åˆ†ç±»äº§å“æ•°é‡
const categoryStats: Record<string, number> = {}
products.forEach(p => {
  categoryStats[p.categoryId] = (categoryStats[p.categoryId] || 0) + 1
})

// ç”Ÿæˆå…ƒæ•°æ®
const meta = {
  totalProducts: products.length,
  brands,
  categoryStats,
  lastUpdated: new Date().toISOString()
}

// å†™å…¥æ–‡ä»¶
const outputPath = path.join(__dirname, '../public/data/products-meta.json')
fs.writeFileSync(outputPath, JSON.stringify(meta, null, 2))

console.log('âœ… å…ƒæ•°æ®ç”ŸæˆæˆåŠŸ!')
console.log(`   - äº§å“æ€»æ•°: ${meta.totalProducts}`)
console.log(`   - å“ç‰Œæ•°é‡: ${brands.length}`)
console.log(`   - è¾“å‡ºè·¯å¾„: ${outputPath}`)
```

#### æ­¥éª¤4ï¼šæ”¹é€  productStore.ts

**æ–‡ä»¶ï¼š`src/stores/productStore.ts`**

```typescript
import { defineStore } from 'pinia'
import { ref, computed, reactive } from 'vue'
import type { Product, ProductFilters, SortOption } from '@/types'

// API åŸºç¡€è·¯å¾„
const API_BASE = import.meta.env.PROD ? '/api' : 'http://localhost:3000/api'

interface PaginationInfo {
  page: number
  pageSize: number
  total: number
  totalPages: number
  hasNextPage: boolean
  hasPrevPage: boolean
}

interface ProductsResponse {
  success: boolean
  data: {
    items: Product[]
    pagination: PaginationInfo
  }
  error?: string
}

interface ProductMeta {
  totalProducts: number
  brands: string[]
  categoryStats: Record<string, number>
  lastUpdated: string
}

export const useProductStore = defineStore('product', () => {
  // ========================================
  // State
  // ========================================
  
  // å½“å‰é¡µäº§å“åˆ—è¡¨
  const products = ref<Product[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  // åˆ†é¡µä¿¡æ¯
  const pagination = reactive<PaginationInfo>({
    page: 1,
    pageSize: 12,
    total: 0,
    totalPages: 0,
    hasNextPage: false,
    hasPrevPage: false
  })

  // å…ƒæ•°æ®ï¼ˆå“ç‰Œåˆ—è¡¨ç­‰ï¼‰
  const meta = ref<ProductMeta | null>(null)
  const metaLoaded = ref(false)

  // ç­›é€‰çŠ¶æ€
  const filters = ref<ProductFilters>({
    search: '',
    categoryId: '',
    brand: ''
  })

  // æ’åºçŠ¶æ€
  const sortBy = ref<SortOption>('name-asc')

  // å•ä¸ªäº§å“è¯¦æƒ…ç¼“å­˜
  const productCache = new Map<string, Product>()

  // ========================================
  // Getters
  // ========================================
  
  // è·å–æ‰€æœ‰å“ç‰Œåˆ—è¡¨ï¼ˆä»å…ƒæ•°æ®ï¼‰
  const allBrands = computed(() => meta.value?.brands || [])

  // è·å–åˆ†ç±»äº§å“æ•°é‡ç»Ÿè®¡
  const categoryStats = computed(() => meta.value?.categoryStats || {})

  // äº§å“æ€»æ•°
  const totalProducts = computed(() => meta.value?.totalProducts || 0)

  // ========================================
  // Actions
  // ========================================
  
  /**
   * åŠ è½½äº§å“å…ƒæ•°æ®ï¼ˆå“ç‰Œåˆ—è¡¨ã€åˆ†ç±»ç»Ÿè®¡ç­‰ï¼‰
   * è¿™ä¸ªæ•°æ®é‡å°ï¼Œå¯ä»¥ä¸€æ¬¡æ€§åŠ è½½
   */
  async function loadMeta() {
    if (metaLoaded.value) return

    try {
      const response = await fetch('/data/products-meta.json')
      if (response.ok) {
        meta.value = await response.json()
        metaLoaded.value = true
      }
    } catch (e) {
      console.error('åŠ è½½äº§å“å…ƒæ•°æ®å¤±è´¥:', e)
    }
  }

  /**
   * åŠ è½½äº§å“åˆ—è¡¨ï¼ˆåˆ†é¡µï¼‰
   */
  async function loadProducts(page: number = 1, pageSize: number = 12) {
    loading.value = true
    error.value = null

    try {
      // æ„å»ºæŸ¥è¯¢å‚æ•°
      const params = new URLSearchParams({
        page: String(page),
        pageSize: String(pageSize),
        sortBy: sortBy.value
      })

      if (filters.value.search) {
        params.set('search', filters.value.search)
      }
      if (filters.value.categoryId) {
        params.set('categoryId', filters.value.categoryId)
      }
      if (filters.value.brand) {
        params.set('brand', filters.value.brand)
      }

      const response = await fetch(`${API_BASE}/products?${params}`)
      const result: ProductsResponse = await response.json()

      if (result.success) {
        products.value = result.data.items
        Object.assign(pagination, result.data.pagination)
      } else {
        throw new Error(result.error || 'åŠ è½½å¤±è´¥')
      }
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'åŠ è½½äº§å“æ•°æ®å¤±è´¥'
      console.error('åŠ è½½äº§å“æ•°æ®å¤±è´¥:', e)
    } finally {
      loading.value = false
    }
  }

  /**
   * æ ¹æ®IDè·å–äº§å“è¯¦æƒ…
   */
  async function getProductById(id: string): Promise<Product | null> {
    // å…ˆæ£€æŸ¥ç¼“å­˜
    if (productCache.has(id)) {
      return productCache.get(id)!
    }

    // å†æ£€æŸ¥å½“å‰åˆ—è¡¨
    const inList = products.value.find(p => p.id === id)
    if (inList) {
      productCache.set(id, inList)
      return inList
    }

    // ä»APIè·å–
    try {
      const response = await fetch(`${API_BASE}/products/${id}`)
      const result = await response.json()

      if (result.success) {
        productCache.set(id, result.data)
        return result.data
      }
      return null
    } catch (e) {
      console.error('è·å–äº§å“è¯¦æƒ…å¤±è´¥:', e)
      return null
    }
  }

  /**
   * è·³è½¬åˆ°æŒ‡å®šé¡µ
   */
  async function goToPage(page: number) {
    if (page >= 1 && page <= pagination.totalPages) {
      await loadProducts(page, pagination.pageSize)
    }
  }

  /**
   * è®¾ç½®æ¯é¡µæ•°é‡
   */
  async function setPageSize(size: number) {
    await loadProducts(1, size)
  }

  /**
   * æ›´æ–°ç­›é€‰æ¡ä»¶å¹¶é‡æ–°åŠ è½½
   */
  async function setFilter<K extends keyof ProductFilters>(
    key: K, 
    value: ProductFilters[K]
  ) {
    filters.value[key] = value
    await loadProducts(1, pagination.pageSize)
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç­›é€‰å¹¶é‡æ–°åŠ è½½
   */
  async function clearAllFilters() {
    filters.value = {
      search: '',
      categoryId: '',
      brand: ''
    }
    await loadProducts(1, pagination.pageSize)
  }

  /**
   * è®¾ç½®æ’åºå¹¶é‡æ–°åŠ è½½
   */
  async function setSortBy(sort: SortOption) {
    sortBy.value = sort
    await loadProducts(pagination.page, pagination.pageSize)
  }

  return {
    // State
    products,
    loading,
    error,
    pagination,
    filters,
    sortBy,
    meta,
    
    // Getters
    allBrands,
    categoryStats,
    totalProducts,
    
    // Actions
    loadMeta,
    loadProducts,
    getProductById,
    goToPage,
    setPageSize,
    setFilter,
    clearAllFilters,
    setSortBy
  }
})
```

#### æ­¥éª¤5ï¼šæ”¹é€  ProductCenter.vue

**æ–‡ä»¶ï¼š`src/views/products/ProductCenter.vue`ï¼ˆå…³é”®æ”¹åŠ¨éƒ¨åˆ†ï¼‰**

```vue
<script setup lang="ts">
import { onMounted, watch, computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useProductStore } from '@/stores/productStore'
// ... å…¶ä»–å¯¼å…¥

const route = useRoute()
const router = useRouter()
const productStore = useProductStore()

// ä¸å†ä½¿ç”¨ usePagination hookï¼Œç›´æ¥ä½¿ç”¨ store çš„åˆ†é¡µçŠ¶æ€
const pagination = computed(() => productStore.pagination)
const products = computed(() => productStore.products)
const loading = computed(() => productStore.loading)

// åˆå§‹åŒ–åŠ è½½
onMounted(async () => {
  // åŠ è½½å…ƒæ•°æ®ï¼ˆå“ç‰Œåˆ—è¡¨ç­‰ï¼‰
  await productStore.loadMeta()
  
  // ä» URL è¯»å–åˆå§‹å‚æ•°
  const page = parseInt(route.query.page as string) || 1
  const categoryId = route.query.category as string || ''
  const brand = route.query.brand as string || ''
  const search = route.query.search as string || ''

  // è®¾ç½®ç­›é€‰æ¡ä»¶ï¼ˆä¸è§¦å‘åŠ è½½ï¼‰
  productStore.filters.categoryId = categoryId
  productStore.filters.brand = brand
  productStore.filters.search = search

  // åŠ è½½äº§å“
  await productStore.loadProducts(page)
})

// ç›‘å¬ç­›é€‰æ¡ä»¶å˜åŒ–ï¼ŒåŒæ­¥åˆ° URL
watch(
  () => [
    productStore.filters,
    productStore.pagination.page
  ],
  () => {
    const query: Record<string, string> = {}
    
    if (productStore.filters.search) {
      query.search = productStore.filters.search
    }
    if (productStore.filters.categoryId) {
      query.category = productStore.filters.categoryId
    }
    if (productStore.filters.brand) {
      query.brand = productStore.filters.brand
    }
    if (productStore.pagination.page > 1) {
      query.page = String(productStore.pagination.page)
    }

    router.replace({ query })
  },
  { deep: true }
)

// åˆ†é¡µæ“ä½œ
const goToPage = (page: number) => {
  productStore.goToPage(page)
  // æ»šåŠ¨åˆ°äº§å“åŒºåŸŸ
  document.querySelector('.products-section')?.scrollIntoView({
    behavior: 'smooth',
    block: 'start'
  })
}

// æœç´¢
const handleSearch = () => {
  productStore.setFilter('search', searchInputValue.value.trim())
}

// ç­›é€‰
const handleCategoryChange = (categoryId: string) => {
  productStore.setFilter('categoryId', categoryId)
}

const handleBrandChange = (brand: string) => {
  productStore.setFilter('brand', brand)
}
</script>

<template>
  <!-- åˆ†é¡µå™¨éƒ¨åˆ†çš„æ”¹åŠ¨ -->
  <div class="pagination">
    <button 
      :disabled="!pagination.hasPrevPage"
      @click="goToPage(pagination.page - 1)"
    >
      ä¸Šä¸€é¡µ
    </button>
    
    <span>{{ pagination.page }} / {{ pagination.totalPages }}</span>
    
    <button 
      :disabled="!pagination.hasNextPage"
      @click="goToPage(pagination.page + 1)"
    >
      ä¸‹ä¸€é¡µ
    </button>
  </div>
</template>
```

#### æ­¥éª¤6ï¼šæ”¹é€  ProductDetail.vue

```vue
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useProductStore } from '@/stores/productStore'

const route = useRoute()
const router = useRouter()
const productStore = useProductStore()

const product = ref<Product | null>(null)
const loading = ref(true)
const error = ref<string | null>(null)

onMounted(async () => {
  const id = route.params.id as string
  
  loading.value = true
  try {
    product.value = await productStore.getProductById(id)
    if (!product.value) {
      error.value = 'äº§å“ä¸å­˜åœ¨'
    }
  } catch (e) {
    error.value = 'åŠ è½½å¤±è´¥'
  } finally {
    loading.value = false
  }
})
</script>
```

#### æ­¥éª¤7ï¼šé…ç½® Vercel

**æ–‡ä»¶ï¼š`vercel.json`**

```json
{
  "version": 2,
  "builds": [
    {
      "src": "package.json",
      "use": "@vercel/static-build",
      "config": {
        "distDir": "dist"
      }
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    },
    {
      "src": "/(.*)",
      "dest": "/dist/$1"
    }
  ],
  "functions": {
    "api/**/*.ts": {
      "memory": 256,
      "maxDuration": 10
    }
  }
}
```

#### æ­¥éª¤8ï¼šæ›´æ–° package.json

```json
{
  "scripts": {
    "dev": "vite",
    "build": "npm run generate-meta && vite build",
    "generate-meta": "ts-node scripts/generate-meta.ts",
    "preview": "vite preview"
  }
}
```

### 3.4 æœ¬åœ°å¼€å‘é…ç½®

ç”±äºæœ¬åœ°å¼€å‘æ—¶æ²¡æœ‰ Vercel Functionsï¼Œéœ€è¦é…ç½®ä»£ç†æˆ–ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨ï¼š

**æ–¹æ¡ˆ1ï¼šä½¿ç”¨ Vite ä»£ç†ï¼ˆæ¨èï¼‰**

**æ–‡ä»¶ï¼š`vite.config.ts`**

```typescript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true
      }
    }
  }
})
```

**æœ¬åœ° API æœåŠ¡å™¨ï¼ˆå¼€å‘ç”¨ï¼‰**

**æ–‡ä»¶ï¼š`scripts/dev-server.ts`**

```typescript
import express from 'express'
import cors from 'cors'
import productsData from '../data/products.json'

const app = express()
app.use(cors())

app.get('/api/products', (req, res) => {
  // ä¸ Vercel Function ç›¸åŒçš„é€»è¾‘
  const { page = '1', pageSize = '12', search = '', categoryId = '', brand = '', sortBy = 'name-asc' } = req.query
  
  // ... ç­›é€‰ã€åˆ†é¡µé€»è¾‘
  
  res.json({ success: true, data: { items, pagination } })
})

app.get('/api/products/:id', (req, res) => {
  const product = productsData.find(p => p.id === req.params.id)
  if (product) {
    res.json({ success: true, data: product })
  } else {
    res.status(404).json({ success: false, error: 'äº§å“ä¸å­˜åœ¨' })
  }
})

app.listen(3001, () => {
  console.log('ğŸš€ å¼€å‘APIæœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:3001')
})
```

æ·»åŠ åˆ° package.jsonï¼š

```json
{
  "scripts": {
    "dev:api": "ts-node scripts/dev-server.ts",
    "dev": "concurrently \"npm run dev:api\" \"vite\""
  },
  "devDependencies": {
    "express": "^4.18.2",
    "concurrently": "^8.2.0"
  }
}
```

### 3.5 éƒ¨ç½²æµç¨‹

1. **å°†ä»£ç æ¨é€åˆ° GitHub**
2. **åœ¨ Vercel åˆ›å»ºé¡¹ç›®å¹¶å…³è”ä»“åº“**
3. **é…ç½®æ„å»ºå‘½ä»¤**ï¼š`npm run build`
4. **é…ç½®è¾“å‡ºç›®å½•**ï¼š`dist`
5. **éƒ¨ç½²å®Œæˆåè‡ªåŠ¨è·å¾— API ç«¯ç‚¹**

---

## å››ã€æ–¹æ¡ˆBï¼šé™æ€æ•°æ®åˆ†ç‰‡ï¼ˆçº¯é™æ€å¤‡é€‰ï¼‰

å¦‚æœä¸æƒ³ä½¿ç”¨ Serverlessï¼Œå¯ä»¥é‡‡ç”¨é¢„ç”Ÿæˆåˆ†ç‰‡çš„æ–¹å¼ã€‚

### 4.1 æ–¹æ¡ˆåŸç†

```
æ„å»ºæ—¶ï¼šå°† products.json åˆ†å‰²æˆå¤šä¸ªå°æ–‡ä»¶
è¿è¡Œæ—¶ï¼šæ ¹æ®é¡µç /ç­›é€‰æ¡ä»¶åŠ è½½å¯¹åº”åˆ†ç‰‡
```

### 4.2 é¡¹ç›®ç»“æ„

```
public/data/products/
â”œâ”€â”€ meta.json                 # å…ƒæ•°æ®ï¼ˆæ€»æ•°ã€å“ç‰Œåˆ—è¡¨ç­‰ï¼‰
â”œâ”€â”€ index/
â”‚   â”œâ”€â”€ page-1.json           # ç¬¬1é¡µæ•°æ®ï¼ˆæŒ‰é»˜è®¤æ’åºï¼‰
â”‚   â”œâ”€â”€ page-2.json           # ç¬¬2é¡µæ•°æ®
â”‚   â””â”€â”€ ...
â”œâ”€â”€ category/
â”‚   â”œâ”€â”€ C01/
â”‚   â”‚   â”œâ”€â”€ page-1.json       # åˆ†ç±»C01çš„ç¬¬1é¡µ
â”‚   â”‚   â””â”€â”€ page-2.json
â”‚   â”œâ”€â”€ C02/
â”‚   â”‚   â””â”€â”€ page-1.json
â”‚   â””â”€â”€ ...
â”œâ”€â”€ brand/
â”‚   â”œâ”€â”€ KIRGEN/
â”‚   â”‚   â”œâ”€â”€ page-1.json
â”‚   â”‚   â””â”€â”€ ...
â”‚   â””â”€â”€ ...
â””â”€â”€ detail/
    â”œâ”€â”€ P001.json             # äº§å“P001è¯¦æƒ…
    â”œâ”€â”€ P002.json
    â””â”€â”€ ...
```

### 4.3 ç”Ÿæˆè„šæœ¬

**æ–‡ä»¶ï¼š`scripts/generate-product-shards.ts`**

```typescript
/**
 * äº§å“æ•°æ®åˆ†ç‰‡ç”Ÿæˆè„šæœ¬
 * è¿è¡Œå‘½ä»¤: npx ts-node scripts/generate-product-shards.ts
 */

import * as fs from 'fs'
import * as path from 'path'

interface Product {
  id: string
  name: string
  categoryId: string
  brand: string
  sku: string
  specs: string
  unit: string
  desc: string
}

const PAGE_SIZE = 12
const INPUT_PATH = path.join(__dirname, '../data/products.json')
const OUTPUT_DIR = path.join(__dirname, '../public/data/products')

// æ¸…ç†å¹¶åˆ›å»ºç›®å½•
function ensureDir(dir: string) {
  if (fs.existsSync(dir)) {
    fs.rmSync(dir, { recursive: true })
  }
  fs.mkdirSync(dir, { recursive: true })
}

// åˆ†é¡µå¹¶å†™å…¥æ–‡ä»¶
function writePages(products: Product[], dir: string) {
  ensureDir(dir)
  
  const totalPages = Math.ceil(products.length / PAGE_SIZE)
  
  for (let page = 1; page <= totalPages; page++) {
    const start = (page - 1) * PAGE_SIZE
    const items = products.slice(start, start + PAGE_SIZE)
    
    const pageData = {
      items,
      pagination: {
        page,
        pageSize: PAGE_SIZE,
        total: products.length,
        totalPages,
        hasNextPage: page < totalPages,
        hasPrevPage: page > 1
      }
    }
    
    fs.writeFileSync(
      path.join(dir, `page-${page}.json`),
      JSON.stringify(pageData)
    )
  }
  
  return totalPages
}

// ä¸»å‡½æ•°
function main() {
  console.log('ğŸ”„ å¼€å§‹ç”Ÿæˆäº§å“æ•°æ®åˆ†ç‰‡...')
  
  // è¯»å–åŸå§‹æ•°æ®
  const products: Product[] = JSON.parse(fs.readFileSync(INPUT_PATH, 'utf-8'))
  console.log(`   è¯»å–åˆ° ${products.length} ä¸ªäº§å“`)
  
  // åˆ›å»ºè¾“å‡ºç›®å½•
  ensureDir(OUTPUT_DIR)
  
  // 1. ç”Ÿæˆå…ƒæ•°æ®
  const brands = [...new Set(products.map(p => p.brand).filter(Boolean))].sort()
  const categories = [...new Set(products.map(p => p.categoryId))]
  
  const categoryStats: Record<string, number> = {}
  products.forEach(p => {
    categoryStats[p.categoryId] = (categoryStats[p.categoryId] || 0) + 1
  })
  
  const meta = {
    totalProducts: products.length,
    brands,
    categories,
    categoryStats,
    pageSize: PAGE_SIZE,
    lastUpdated: new Date().toISOString()
  }
  
  fs.writeFileSync(
    path.join(OUTPUT_DIR, 'meta.json'),
    JSON.stringify(meta, null, 2)
  )
  console.log('   âœ… ç”Ÿæˆå…ƒæ•°æ®')
  
  // 2. ç”Ÿæˆå…¨é‡ç´¢å¼•åˆ†é¡µï¼ˆé»˜è®¤æ’åºï¼‰
  const sortedProducts = [...products].sort((a, b) => 
    a.name.localeCompare(b.name, 'zh-CN')
  )
  const indexDir = path.join(OUTPUT_DIR, 'index')
  const indexPages = writePages(sortedProducts, indexDir)
  console.log(`   âœ… ç”Ÿæˆå…¨é‡ç´¢å¼•: ${indexPages} é¡µ`)
  
  // 3. æŒ‰åˆ†ç±»ç”Ÿæˆåˆ†ç‰‡
  const categoryDir = path.join(OUTPUT_DIR, 'category')
  ensureDir(categoryDir)
  
  categories.forEach(categoryId => {
    const categoryProducts = sortedProducts.filter(p => p.categoryId === categoryId)
    if (categoryProducts.length > 0) {
      const dir = path.join(categoryDir, categoryId)
      writePages(categoryProducts, dir)
    }
  })
  console.log(`   âœ… ç”Ÿæˆåˆ†ç±»ç´¢å¼•: ${categories.length} ä¸ªåˆ†ç±»`)
  
  // 4. æŒ‰å“ç‰Œç”Ÿæˆåˆ†ç‰‡
  const brandDir = path.join(OUTPUT_DIR, 'brand')
  ensureDir(brandDir)
  
  brands.forEach(brand => {
    const brandProducts = sortedProducts.filter(p => p.brand === brand)
    if (brandProducts.length > 0) {
      // å“ç‰Œåå¯èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œéœ€è¦ç¼–ç 
      const safeBrandName = encodeURIComponent(brand)
      const dir = path.join(brandDir, safeBrandName)
      writePages(brandProducts, dir)
    }
  })
  console.log(`   âœ… ç”Ÿæˆå“ç‰Œç´¢å¼•: ${brands.length} ä¸ªå“ç‰Œ`)
  
  // 5. ç”Ÿæˆäº§å“è¯¦æƒ…æ–‡ä»¶
  const detailDir = path.join(OUTPUT_DIR, 'detail')
  ensureDir(detailDir)
  
  products.forEach(product => {
    fs.writeFileSync(
      path.join(detailDir, `${product.id}.json`),
      JSON.stringify(product)
    )
  })
  console.log(`   âœ… ç”Ÿæˆäº§å“è¯¦æƒ…: ${products.length} ä¸ªæ–‡ä»¶`)
  
  console.log('\nâœ¨ æ•°æ®åˆ†ç‰‡ç”Ÿæˆå®Œæˆ!')
  console.log(`   è¾“å‡ºç›®å½•: ${OUTPUT_DIR}`)
}

main()
```

### 4.4 æ”¹é€  productStore.tsï¼ˆé™æ€åˆ†ç‰‡ç‰ˆæœ¬ï¼‰

```typescript
import { defineStore } from 'pinia'
import { ref, computed, reactive } from 'vue'
import type { Product, ProductFilters, SortOption } from '@/types'

const DATA_BASE = '/data/products'

interface PaginationInfo {
  page: number
  pageSize: number
  total: number
  totalPages: number
  hasNextPage: boolean
  hasPrevPage: boolean
}

interface ProductMeta {
  totalProducts: number
  brands: string[]
  categories: string[]
  categoryStats: Record<string, number>
  pageSize: number
  lastUpdated: string
}

export const useProductStore = defineStore('product', () => {
  // State
  const products = ref<Product[]>([])
  const loading = ref(false)
  const error = ref<string | null>(null)
  
  const pagination = reactive<PaginationInfo>({
    page: 1,
    pageSize: 12,
    total: 0,
    totalPages: 0,
    hasNextPage: false,
    hasPrevPage: false
  })

  const meta = ref<ProductMeta | null>(null)
  const metaLoaded = ref(false)

  const filters = ref<ProductFilters>({
    search: '',
    categoryId: '',
    brand: ''
  })

  // Getters
  const allBrands = computed(() => meta.value?.brands || [])
  const categoryStats = computed(() => meta.value?.categoryStats || {})

  // Actions
  async function loadMeta() {
    if (metaLoaded.value) return

    try {
      const response = await fetch(`${DATA_BASE}/meta.json`)
      if (response.ok) {
        meta.value = await response.json()
        metaLoaded.value = true
      }
    } catch (e) {
      console.error('åŠ è½½å…ƒæ•°æ®å¤±è´¥:', e)
    }
  }

  /**
   * åŠ è½½äº§å“åˆ—è¡¨
   * æ ¹æ®ç­›é€‰æ¡ä»¶å†³å®šåŠ è½½å“ªä¸ªåˆ†ç‰‡
   */
  async function loadProducts(page: number = 1) {
    loading.value = true
    error.value = null

    try {
      let url = ''
      
      // æ ¹æ®ç­›é€‰æ¡ä»¶ç¡®å®šæ•°æ®è·¯å¾„
      if (filters.value.categoryId) {
        // åˆ†ç±»ç­›é€‰
        url = `${DATA_BASE}/category/${filters.value.categoryId}/page-${page}.json`
      } else if (filters.value.brand) {
        // å“ç‰Œç­›é€‰
        const safeBrand = encodeURIComponent(filters.value.brand)
        url = `${DATA_BASE}/brand/${safeBrand}/page-${page}.json`
      } else {
        // æ— ç­›é€‰ï¼ŒåŠ è½½å…¨é‡ç´¢å¼•
        url = `${DATA_BASE}/index/page-${page}.json`
      }

      const response = await fetch(url)
      
      if (!response.ok) {
        if (response.status === 404) {
          // åˆ†é¡µè¶…å‡ºèŒƒå›´
          products.value = []
          Object.assign(pagination, {
            page: 1,
            total: 0,
            totalPages: 0,
            hasNextPage: false,
            hasPrevPage: false
          })
          return
        }
        throw new Error('åŠ è½½å¤±è´¥')
      }

      const result = await response.json()
      
      // å¦‚æœæœ‰æœç´¢å…³é”®è¯ï¼Œåœ¨å®¢æˆ·ç«¯è¿›è¡ŒäºŒæ¬¡ç­›é€‰
      if (filters.value.search) {
        const keyword = filters.value.search.toLowerCase()
        result.items = result.items.filter((p: Product) =>
          p.name.toLowerCase().includes(keyword) ||
          p.specs.toLowerCase().includes(keyword) ||
          p.desc.toLowerCase().includes(keyword) ||
          p.brand?.toLowerCase().includes(keyword) ||
          p.sku?.toLowerCase().includes(keyword)
        )
      }

      products.value = result.items
      Object.assign(pagination, result.pagination)
      
    } catch (e) {
      error.value = e instanceof Error ? e.message : 'åŠ è½½å¤±è´¥'
      console.error('åŠ è½½äº§å“å¤±è´¥:', e)
    } finally {
      loading.value = false
    }
  }

  /**
   * è·å–äº§å“è¯¦æƒ…
   */
  async function getProductById(id: string): Promise<Product | null> {
    try {
      const response = await fetch(`${DATA_BASE}/detail/${id}.json`)
      if (response.ok) {
        return await response.json()
      }
      return null
    } catch (e) {
      console.error('è·å–äº§å“è¯¦æƒ…å¤±è´¥:', e)
      return null
    }
  }

  async function goToPage(page: number) {
    await loadProducts(page)
  }

  async function setFilter<K extends keyof ProductFilters>(
    key: K, 
    value: ProductFilters[K]
  ) {
    filters.value[key] = value
    await loadProducts(1)
  }

  async function clearAllFilters() {
    filters.value = { search: '', categoryId: '', brand: '' }
    await loadProducts(1)
  }

  return {
    products,
    loading,
    error,
    pagination,
    filters,
    meta,
    allBrands,
    categoryStats,
    loadMeta,
    loadProducts,
    getProductById,
    goToPage,
    setFilter,
    clearAllFilters
  }
})
```

### 4.5 é™æ€åˆ†ç‰‡æ–¹æ¡ˆçš„å±€é™æ€§

| åŠŸèƒ½ | æ”¯æŒæƒ…å†µ | è¯´æ˜ |
|------|----------|------|
| åˆ†é¡µæµè§ˆ | âœ… å®Œå…¨æ”¯æŒ | é¢„ç”Ÿæˆåˆ†é¡µæ–‡ä»¶ |
| åˆ†ç±»ç­›é€‰ | âœ… å®Œå…¨æ”¯æŒ | é¢„ç”Ÿæˆåˆ†ç±»ç´¢å¼• |
| å“ç‰Œç­›é€‰ | âœ… å®Œå…¨æ”¯æŒ | é¢„ç”Ÿæˆå“ç‰Œç´¢å¼• |
| æœç´¢åŠŸèƒ½ | âš ï¸ éƒ¨åˆ†æ”¯æŒ | åªèƒ½åœ¨å½“å‰é¡µå†…æœç´¢ |
| ç»„åˆç­›é€‰ | âŒ ä¸æ”¯æŒ | åˆ†ç±»+å“ç‰Œç»„åˆéœ€é¢å¤–ç”Ÿæˆ |
| æ’åºåˆ‡æ¢ | âŒ ä¸æ”¯æŒ | éœ€è¦ä¸ºæ¯ç§æ’åºç”Ÿæˆç´¢å¼• |

**é€‚ç”¨åœºæ™¯**ï¼šç­›é€‰æ¡ä»¶ç®€å•ã€ä¸éœ€è¦å¤æ‚æœç´¢çš„æƒ…å†µ

---

## äº”ã€æ–¹æ¡ˆå¯¹æ¯”ä¸é€‰æ‹©å»ºè®®

### 5.1 æ–¹æ¡ˆå¯¹æ¯”è¡¨

| ç‰¹æ€§ | Serverless Functions | é™æ€æ•°æ®åˆ†ç‰‡ |
|------|---------------------|--------------|
| **åˆ†é¡µ** | âœ… çœŸæ­£çš„æœåŠ¡ç«¯åˆ†é¡µ | âœ… é¢„ç”Ÿæˆåˆ†é¡µ |
| **æœç´¢** | âœ… å…¨æ–‡æœç´¢ | âš ï¸ ä»…å½“å‰é¡µ |
| **ç»„åˆç­›é€‰** | âœ… ä»»æ„ç»„åˆ | âŒ éœ€é¢„ç”Ÿæˆ |
| **æ’åº** | âœ… åŠ¨æ€æ’åº | âŒ éœ€é¢„ç”Ÿæˆ |
| **éƒ¨ç½²å¤æ‚åº¦** | ä¸­ç­‰ | ç®€å• |
| **æ„å»ºæ—¶é—´** | å¿« | è¾ƒé•¿ |
| **æ–‡ä»¶æ•°é‡** | å°‘ | å¤š |
| **ç»´æŠ¤æˆæœ¬** | ä½ | ä¸­ |

### 5.2 é€‰æ‹©å»ºè®®

```
å¦‚æœä½ çš„éœ€æ±‚æ˜¯ï¼š
â”œâ”€â”€ éœ€è¦å…¨æ–‡æœç´¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ é€‰æ‹© Serverless Functions
â”œâ”€â”€ éœ€è¦ç»„åˆç­›é€‰ï¼ˆåˆ†ç±»+å“ç‰Œï¼‰â”€â”€â”€â”€â”€â”€â”€â†’ é€‰æ‹© Serverless Functions
â”œâ”€â”€ ç­›é€‰æ¡ä»¶ç®€å•ï¼ŒåªæŒ‰å•ä¸€ç»´åº¦â”€â”€â”€â”€â†’ é€‰æ‹© é™æ€æ•°æ®åˆ†ç‰‡
â”œâ”€â”€ è¿½æ±‚æç®€éƒ¨ç½²ï¼ˆGitHub Pagesï¼‰â”€â”€â†’ é€‰æ‹© é™æ€æ•°æ®åˆ†ç‰‡
â””â”€â”€ è¿½æ±‚æœ€ä½³ç”¨æˆ·ä½“éªŒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ é€‰æ‹© Serverless Functions
```

### 5.3 æ¨èæ–¹æ¡ˆ

**å¯¹äºä¸Šä¸‡äº§å“çš„åœºæ™¯ï¼Œå¼ºçƒˆæ¨èä½¿ç”¨ Serverless Functions æ–¹æ¡ˆ**ï¼ŒåŸå› ï¼š

1. **ç”¨æˆ·ä½“éªŒæ›´å¥½**ï¼šçœŸæ­£çš„æœåŠ¡ç«¯åˆ†é¡µï¼Œé¦–æ¬¡åŠ è½½å¿«
2. **åŠŸèƒ½å®Œæ•´**ï¼šæ”¯æŒå…¨æ–‡æœç´¢å’Œä»»æ„ç»„åˆç­›é€‰
3. **ç»´æŠ¤ç®€å•**ï¼šåªéœ€ç»´æŠ¤ä¸€ä»½æ•°æ®ï¼Œæ— éœ€ç”Ÿæˆå¤§é‡åˆ†ç‰‡
4. **æˆæœ¬ä¸ºé›¶**ï¼šVercel å…è´¹é¢åº¦è¶³å¤Ÿä¸­å°ç½‘ç«™ä½¿ç”¨
5. **æ‰©å±•æ€§å¼º**ï¼šåç»­å¯è½»æ¾æ·»åŠ æ›´å¤š API åŠŸèƒ½

---

## å…­ã€å®æ–½è®¡åˆ’

### 6.1 æ—¶é—´ä¼°ç®—

| é˜¶æ®µ | ä»»åŠ¡ | æ—¶é—´ |
|------|------|------|
| 1 | é¡¹ç›®ç»“æ„è°ƒæ•´ | 0.5å¤© |
| 2 | åˆ›å»º Serverless API | 1å¤© |
| 3 | æ”¹é€  productStore | 0.5å¤© |
| 4 | æ”¹é€ é¡µé¢ç»„ä»¶ | 1å¤© |
| 5 | æœ¬åœ°å¼€å‘é…ç½® | 0.5å¤© |
| 6 | æµ‹è¯•ä¸è°ƒè¯• | 1å¤© |
| 7 | éƒ¨ç½²ä¸Šçº¿ | 0.5å¤© |
| **æ€»è®¡** | | **5å¤©** |

### 6.2 é£é™©ä¸åº”å¯¹

| é£é™© | åº”å¯¹æªæ–½ |
|------|----------|
| Vercel å…è´¹é¢åº¦ä¸è¶³ | ç›‘æ§ç”¨é‡ï¼Œå¿…è¦æ—¶å‡çº§æˆ–ä½¿ç”¨ Cloudflare Workers |
| å†·å¯åŠ¨å»¶è¿Ÿ | ä½¿ç”¨è¾¹ç¼˜å‡½æ•°ï¼Œå‡å°‘å‡½æ•°å¤æ‚åº¦ |
| æ•°æ®æ›´æ–°é¢‘ç¹ | è®¾ç½®åˆç†çš„ç¼“å­˜ç­–ç•¥ |

---

## ä¸ƒã€æ€»ç»“

æœ¬æ–‡æ¡£æä¾›äº†ä¸¤ç§è§£å†³å¤§æ•°æ®é‡äº§å“åˆ†é¡µçš„æ–¹æ¡ˆï¼š

1. **Serverless Functionsï¼ˆæ¨èï¼‰**ï¼šé€‚åˆéœ€è¦å®Œæ•´åŠŸèƒ½çš„åœºæ™¯
2. **é™æ€æ•°æ®åˆ†ç‰‡**ï¼šé€‚åˆç®€å•ç­›é€‰ã€è¿½æ±‚æç®€éƒ¨ç½²çš„åœºæ™¯

å¯¹äºä¸Šä¸‡äº§å“çš„éœ€æ±‚ï¼Œå»ºè®®é‡‡ç”¨ Serverless Functions æ–¹æ¡ˆï¼Œå¯ä»¥åœ¨ä¿æŒé¡¹ç›®ç®€æ´çš„åŒæ—¶ï¼Œæä¾›å®Œæ•´çš„åˆ†é¡µã€æœç´¢ã€ç­›é€‰åŠŸèƒ½ã€‚

å¦‚éœ€å®æ–½ï¼Œè¯·æŒ‰ç…§æœ¬æ–‡æ¡£çš„æ­¥éª¤è¿›è¡Œï¼Œæˆ–è”ç³»å¼€å‘äººå‘˜ååŠ©å®Œæˆã€‚

