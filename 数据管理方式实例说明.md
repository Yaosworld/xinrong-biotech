# 数据管理方式实例说明 - ShowcaseBanner 组件

## 当前问题概述

当前项目中 ShowcaseBanner 组件存在数据管理混乱的问题，以产品中心页面为例：

**JSON配置文件数据：** `public/data/pages/product-center.json`
**组件内部数据：** `src/views/product/ProductCenter.vue`

这两种数据源完全不匹配，导致数据重复、不一致和维护困难。

## 三种数据管理方式的具体实例

### 方式1：配置型数据（JSON配置作为唯一数据源）

**适用场景：** 静态内容、文案、基础布局结构

**实例：产品中心页面的标语和统计项**

#### 1.1 JSON配置文件 `public/data/pages/product-center.json`
```json
{
  "id": "product_center",
  "title": "产品中心",
  "showcase": {
    "summaryLines": [
      "探索我们的产品世界",
      "为您提供最优质的科学仪器与试剂"
    ],
    "stats": [
      {
        "key": "productCount",
        "number": "3000+",
        "label": "产品种类"
      },
      {
        "key": "categoryCount",
        "number": "50+",
        "label": "产品分类"
      },
      {
        "key": "brandCount",
        "number": "100+",
        "label": "合作品牌"
      }
    ]
  }
}
```

#### 1.2 组件直接使用配置数据 `src/views/product/ProductCenter.vue`
```vue
<script setup lang="ts">
import { onMounted } from 'vue'
import ShowcaseBanner from '@/components/common/ShowcaseBanner.vue'

// 直接使用JSON配置数据
const pageConfig = await import('@/data/pages/product-center.json')

// 转换为组件需要的格式
const bannersSlogans = pageConfig.showcase.summaryLines.map(text => ({
  text,
  type: 'primary'
}))

const bannerStats = pageConfig.showcase.stats

onMounted(() => {
  // 页面初始化
})
</script>

<template>
  <div class="product-center pt-[72px]">
    <!-- 直接使用配置数据，无需额外处理 -->
    <ShowcaseBanner
      :slogans="bannersSlogans"
      :stats="bannerStats"
    />
  </div>
</template>
```

#### 1.3 ShowcaseBanner 组件接收配置数据
```vue
<script setup lang="ts">
interface BannerSlogan {
  text: string
  type?: 'primary' | 'secondary'
}

interface StatItem {
  key: string
  number: string
  label: string
}

defineProps<{
  slogans: BannerSlogan[]
  stats: StatItem[]
}>()
</script>

<template>
  <section class="showcase-section">
    <!-- 标语区域 - 循环显示所有标语 -->
    <div class="slogans-container">
      <div
        v-for="(slogan, index) in slogans"
        :key="index"
        class="slogan-item"
        :class="`slogan-${slogan.type || 'primary'}`"
      >
        {{ slogan.text }}
      </div>
    </div>

    <!-- 统计项区域 - 根据数量自动调整布局 -->
    <div
      v-if="stats && stats.length"
      class="stats-grid"
      :class="`stats-count-${stats.length}`"
    >
      <div
        v-for="stat in stats"
        :key="stat.key"
        class="stat-item"
      >
        <div class="stat-number">{{ stat.number }}</div>
        <div class="stat-label">{{ stat.label }}</div>
      </div>
    </div>
  </section>
</template>
```

**优势：**
- 数据单一来源，易于维护
- 配置变更只需修改JSON文件
- 组件逻辑简单，只负责展示

**缺点：**
- 无法显示动态数据（如实时产品数量）
- 需要手动更新统计数据

---

### 方式2：动态数据（Store实时计算）

**适用场景：** 需要实时更新、根据用户操作或时间变化的数据

**实例：产品中心页面的实时统计数据**

#### 2.1 JSON配置只定义统计项结构
```json
{
  "showcase": {
    "summaryLines": [
      "探索我们的产品世界",
      "为您提供最优质的科学仪器与试剂"
    ],
    "statKeys": [
      {
        "key": "productCount",
        "label": "产品种类"
      },
      {
        "key": "categoryCount",
        "label": "产品分类"
      },
      {
        "key": "brandCount",
        "label": "合作品牌"
      },
      {
        "key": "activePromotions",
        "label": "正在进行的活动"
      }
    ]
  }
}
```

#### 2.2 Store 提供动态数据
```typescript
// src/stores/productStore.ts
export const useProductStore = defineStore('product', {
  state: () => ({
    products: [] as Product[],
    categories: [] as Category[],
    brands: [] as Brand[],
    promotions: [] as Promotion[]
  }),

  getters: {
    // 实时计算产品数量
    productCount(): string {
      return `${this.products.length}+`
    },

    // 实时计算分类数量
    categoryCount(): string {
      return `${this.categories.length}+`
    },

    // 实时计算品牌数量
    brandCount(): string {
      return `${this.brands.length}+`
    },

    // 实时计算正在进行的活动数量
    activePromotionsCount(): string {
      const activeCount = this.promotions.filter(p =>
        new Date(p.endDate) > new Date() && new Date(p.startDate) <= new Date()
      ).length
      return `${activeCount}+`
    },

    // 根据配置键获取统计数据
    getDynamicStats() {
      return (statKeys: Array<{key: string, label: string}>) => {
        return statKeys.map(statKey => ({
          key: statKey.key,
          label: statKey.label,
          number: this[`${statKey.key}`] || '0' // 动态调用对应的getter
        }))
      }
    }
  }
})
```

#### 2.3 组件使用动态数据
```vue
<script setup lang="ts">
import { computed, onMounted } from 'vue'
import { useProductStore } from '@/stores/productStore'
import ShowcaseBanner from '@/components/common/ShowcaseBanner.vue'

const productStore = useProductStore()

// 加载页面配置
const pageConfig = await import('@/data/pages/product-center.json')

// 动态计算标语数据
const bannersSlogans = computed(() =>
  pageConfig.showcase.summaryLines.map(text => ({
    text,
    type: 'primary'
  }))
)

// 动态计算统计数据
const bannerStats = computed(() =>
  productStore.getDynamicStats(pageConfig.showcase.statKeys)
)

// 模拟数据变化（实际项目中可能来自API）
const refreshStats = async () => {
  await productStore.loadProducts()
  await productStore.loadBrands()
  await productStore.loadPromotions()
  console.log('统计数据已更新:', bannerStats.value)
}

onMounted(() => {
  refreshStats()

  // 模拟定期更新（可选）
  setInterval(refreshStats, 30000) // 每30秒更新一次
})
</script>

<template>
  <div class="product-center pt-[72px]">
    <!-- 使用动态数据 -->
    <ShowcaseBanner
      :slogans="bannersSlogans"
      :stats="bannerStats"
    />

    <!-- 添加刷新按钮，用于演示 -->
    <div class="container-base mt-4">
      <button
        @click="refreshStats"
        class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
      >
        刷新统计数据
      </button>
      <div class="mt-2 text-sm text-gray-600">
        最后更新: {{ new Date().toLocaleTimeString() }}
      </div>
    </div>
  </div>
</template>
```

**优势：**
- 数据实时更新，反映当前状态
- 用户能看到最新的数据变化
- 适合展示动态内容

**缺点：**
- 依赖Store和API，逻辑复杂
- 需要处理加载状态和错误
- 性能开销较大

---

### 方式3：混合数据（配置模板 + 动态值）

**适用场景：** 需要结合静态配置和动态数据，实现最佳平衡

**实例：产品中心页面的智能统计数据**

#### 3.1 JSON配置定义完整模板
```json
{
  "showcase": {
    "summaryLines": [
      "探索我们的产品世界",
      "为您提供最优质的科学仪器与试剂"
    ],
    "stats": [
      {
        "key": "productCount",
        "label": "产品种类",
        "defaultNumber": "3000+",
        "format": "dynamic", // 标识为动态数据
        "minThreshold": 1000, // 最小阈值
        "suffix": "+" // 后缀
      },
      {
        "key": "categoryCount",
        "label": "产品分类",
        "defaultNumber": "50+",
        "format": "dynamic",
        "minThreshold": 10,
        "suffix": "+"
      },
      {
        "key": "brandCount",
        "label": "合作品牌",
        "defaultNumber": "100+",
        "format": "static", // 标识为静态数据
        "minThreshold": 50,
        "suffix": "+"
      },
      {
        "key": "satisfactionRate",
        "label": "客户满意度",
        "defaultNumber": "98%",
        "format": "calculated", // 标识为计算数据
        "calculation": "positiveReviews / totalReviews * 100",
        "suffix": "%"
      }
    ]
  }
}
```

#### 3.2 数据服务层处理混合逻辑
```typescript
// src/services/pageDataService.ts
import { useProductStore } from '@/stores/productStore'
import { useReviewStore } from '@/stores/reviewStore'

export class PageDataService {
  private productStore = useProductStore()
  private reviewStore = useReviewStore()

  async getPageStats(pageId: string) {
    // 加载页面配置
    const config = await import(`@/data/pages/${pageId}.json`)

    // 加载必要的动态数据
    await this.loadRequiredData(config.showcase.stats)

    // 处理每个统计项
    const processedStats = await Promise.all(
      config.showcase.stats.map(async (stat: any) => {
        return await this.processStatItem(stat)
      })
    )

    return processedStats
  }

  private async loadRequiredData(statsConfig: any[]) {
    const needsProducts = statsConfig.some(s => s.key.includes('product'))
    const needsBrands = statsConfig.some(s => s.key.includes('brand'))
    const needsReviews = statsConfig.some(s => s.key.includes('satisfaction'))

    const loadPromises = []

    if (needsProducts) loadPromises.push(this.productStore.loadProducts())
    if (needsBrands) loadPromises.push(this.productStore.loadBrands())
    if (needsReviews) loadPromises.push(this.reviewStore.loadReviews())

    await Promise.all(loadPromises)
  }

  private async processStatItem(statConfig: any) {
    const { key, defaultNumber, format, suffix, minThreshold, calculation } = statConfig

    switch (format) {
      case 'dynamic':
        return await this.getDynamicValue(statConfig)

      case 'static':
        return {
          key,
          number: defaultNumber,
          label: statConfig.label
        }

      case 'calculated':
        return await this.getCalculatedValue(statConfig)

      default:
        return {
          key,
          number: defaultNumber,
          label: statConfig.label
        }
    }
  }

  private async getDynamicValue(statConfig: any) {
    const { key, defaultNumber, suffix, minThreshold } = statConfig
    let dynamicValue = 0

    switch (key) {
      case 'productCount':
        dynamicValue = this.productStore.products.length
        break
      case 'categoryCount':
        dynamicValue = this.productStore.categories.length
        break
      case 'brandCount':
        dynamicValue = this.productStore.brands.length
        break
      default:
        dynamicValue = 0
    }

    // 应用最小阈值和格式化
    const formattedValue = dynamicValue >= minThreshold
      ? `${dynamicValue}${suffix || ''}`
      : defaultNumber

    return {
      key,
      number: formattedValue,
      label: statConfig.label,
      isDynamic: true,
      actualValue: dynamicValue
    }
  }

  private async getCalculatedValue(statConfig: any) {
    const { key, defaultNumber, suffix, calculation } = statConfig
    let calculatedValue = 0

    switch (key) {
      case 'satisfactionRate':
        const positiveReviews = this.reviewStore.positiveReviews
        const totalReviews = this.reviewStore.totalReviews
        calculatedValue = totalReviews > 0 ? (positiveReviews / totalReviews * 100) : 0
        break
      default:
        calculatedValue = 0
    }

    const formattedValue = `${Math.round(calculatedValue)}${suffix || ''}`

    return {
      key,
      number: formattedValue,
      label: statConfig.label,
      isCalculated: true,
      actualValue: calculatedValue
    }
  }
}
```

#### 3.3 Vue Compose Hook 封装
```typescript
// src/composables/usePageData.ts
import { ref, computed, onMounted, watch } from 'vue'
import { PageDataService } from '@/services/pageDataService'

export function usePageData(pageId: string) {
  const pageDataService = new PageDataService()

  const loading = ref(true)
  const error = ref<string | null>(null)
  const pageConfig = ref<any>(null)
  const pageStats = ref<any[]>([])

  // 响应式计算标语数据
  const slogans = computed(() => {
    if (!pageConfig.value?.showcase?.summaryLines) return []

    return pageConfig.value.showcase.summaryLines.map((text: string) => ({
      text,
      type: 'primary'
    }))
  })

  // 异步加载页面数据
  const loadPageData = async () => {
    try {
      loading.value = true
      error.value = null

      // 加载配置
      const configModule = await import(`@/data/pages/${pageId}.json`)
      pageConfig.value = configModule.default

      // 加载并处理统计数据
      pageStats.value = await pageDataService.getPageStats(pageId)

      console.log('页面数据加载完成:', {
        config: pageConfig.value,
        stats: pageStats.value
      })

    } catch (err) {
      error.value = err instanceof Error ? err.message : '加载失败'
      console.error('页面数据加载失败:', err)
    } finally {
      loading.value = false
    }
  }

  // 手动刷新数据
  const refreshPageData = async () => {
    console.log('手动刷新页面数据...')
    await loadPageData()
  }

  // 自动刷新动态数据
  const refreshDynamicStats = async () => {
    if (!pageConfig.value) return

    console.log('刷新动态统计数据...')
    pageStats.value = await pageDataService.getPageStats(pageId)
  }

  // 监听动态数据变化
  const startAutoRefresh = (intervalMs: number = 30000) => {
    return setInterval(refreshDynamicStats, intervalMs)
  }

  onMounted(() => {
    loadPageData()
  })

  return {
    // 状态
    loading: readonly(loading),
    error: readonly(error),

    // 数据
    pageConfig: readonly(pageConfig),
    slogans,
    pageStats: readonly(pageStats),

    // 方法
    loadPageData,
    refreshPageData,
    refreshDynamicStats,
    startAutoRefresh
  }
}
```

#### 3.4 组件使用混合数据
```vue
<script setup lang="ts">
import { onUnmounted } from 'vue'
import { usePageData } from '@/composables/usePageData'
import ShowcaseBanner from '@/components/common/ShowcaseBanner.vue'

// 使用Hook管理页面数据
const {
  loading,
  error,
  slogans,
  pageStats,
  loadPageData,
  refreshPageData,
  refreshDynamicStats,
  startAutoRefresh
} = usePageData('product-center')

// 启动自动刷新（每30秒）
const refreshInterval = startAutoRefresh(30000)

// 组件卸载时清理定时器
onUnmounted(() => {
  if (refreshInterval) {
    clearInterval(refreshInterval)
  }
})

// 调试方法
const debugPageData = () => {
  console.log('=== 页面数据调试信息 ===')
  console.log('标语数据:', slogans.value)
  console.log('统计数据:', pageStats.value)
  console.log('数据状态:', { loading: loading.value, error: error.value })

  // 显示每种类型的数据
  const dynamicStats = pageStats.value.filter(stat => stat.isDynamic)
  const calculatedStats = pageStats.value.filter(stat => stat.isCalculated)
  const staticStats = pageStats.value.filter(stat => !stat.isDynamic && !stat.isCalculated)

  console.log('动态数据:', dynamicStats)
  console.log('计算数据:', calculatedStats)
  console.log('静态数据:', staticStats)
}
</script>

<template>
  <div class="product-center pt-[72px]">
    <!-- 加载状态 -->
    <div v-if="loading" class="text-center py-8">
      <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      <p class="mt-2 text-gray-600">加载页面数据中...</p>
    </div>

    <!-- 错误状态 -->
    <div v-else-if="error" class="text-center py-8">
      <div class="text-red-500 mb-4">{{ error }}</div>
      <button
        @click="loadPageData"
        class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
      >
        重新加载
      </button>
    </div>

    <!-- 正常显示 -->
    <template v-else>
      <!-- 使用混合数据的ShowcaseBanner -->
      <ShowcaseBanner
        :slogans="slogans"
        :stats="pageStats"
      />

      <!-- 调试和操作区域 -->
      <div class="container-base mt-8 p-4 bg-gray-50 rounded-lg">
        <h3 class="text-lg font-semibold mb-4">数据管理演示</h3>

        <!-- 数据类型展示 -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
          <div class="p-3 bg-blue-50 rounded">
            <h4 class="font-medium text-blue-700">动态数据</h4>
            <div class="text-sm text-blue-600">
              {{ pageStats.filter(s => s.isDynamic).map(s => s.label).join(', ') || '无' }}
            </div>
          </div>

          <div class="p-3 bg-green-50 rounded">
            <h4 class="font-medium text-green-700">计算数据</h4>
            <div class="text-sm text-green-600">
              {{ pageStats.filter(s => s.isCalculated).map(s => s.label).join(', ') || '无' }}
            </div>
          </div>

          <div class="p-3 bg-gray-50 rounded">
            <h4 class="font-medium text-gray-700">静态数据</h4>
            <div class="text-sm text-gray-600">
              {{ pageStats.filter(s => !s.isDynamic && !s.isCalculated).map(s => s.label).join(', ') || '无' }}
            </div>
          </div>
        </div>

        <!-- 操作按钮 -->
        <div class="flex flex-wrap gap-2">
          <button
            @click="refreshPageData"
            class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
          >
            刷新全部数据
          </button>

          <button
            @click="refreshDynamicStats"
            class="px-3 py-1 bg-green-500 text-white rounded text-sm hover:bg-green-600"
          >
            仅刷新动态数据
          </button>

          <button
            @click="debugPageData"
            class="px-3 py-1 bg-purple-500 text-white rounded text-sm hover:bg-purple-600"
          >
            调试数据
          </button>
        </div>

        <!-- 实时数据展示 -->
        <div class="mt-4 p-3 bg-white rounded border">
          <h4 class="font-medium mb-2">当前数据状态</h4>
          <div class="text-xs space-y-1">
            <div>标语数量: {{ slogans.length }}</div>
            <div>统计项数量: {{ pageStats.length }}</div>
            <div>最后更新: {{ new Date().toLocaleTimeString() }}</div>
            <div v-if="pageStats.some(s => s.isDynamic)" class="text-blue-600">
              包含 {{ pageStats.filter(s => s.isDynamic).length }} 项动态数据
            </div>
          </div>
        </div>
      </div>
    </template>
  </div>
</template>
```

## 三种方式对比总结

| 特性 | 配置型数据 | 动态数据 | 混合数据 |
|------|------------|----------|----------|
| **数据来源** | JSON文件 | Store/API | JSON + Store/API |
| **更新频率** | 手动更新 | 实时/定期更新 | 部分实时更新 |
| **性能** | 最高 | 最低 | 中等 |
| **维护成本** | 低 | 高 | 中等 |
| **用户体验** | 静态展示 | 动态变化 | 智能平衡 |
| **适用场景** | 基础文案、静态信息 | 实时数据、用户数据 | 大部分业务场景 |
| **开发复杂度** | 简单 | 复杂 | 中等复杂 |

## 推荐方案

对于你的项目，我推荐使用**混合数据**方案，因为它：

1. **兼顾了性能和体验**：静态文案保持高性能，动态数据提供良好体验
2. **易于维护**：配置文件管理结构，Store管理状态
3. **扩展性强**：可以灵活添加新的数据类型
4. **向后兼容**：可以逐步从现有方式迁移

这样既解决了当前的数据不一致问题，又为未来的功能扩展奠定了良好的基础。